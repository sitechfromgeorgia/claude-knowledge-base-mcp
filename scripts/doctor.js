#!/usr/bin/env node

/**
 * 🇬🇪 Claude Knowledge Base MCP v3.0 - System Doctor
 * Built with love from Batumi, Georgia 🌊
 * 
 * Comprehensive system diagnosis and health checks
 */

import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { existsSync, statSync, readFileSync } from 'fs';
import { homedir, platform, arch, totalmem, freemem, cpus } from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// 🎨 Console formatting
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};\n\nfunction formatBytes(bytes) {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];\n}\n\nfunction log(message, color = 'white', icon = '') {\n  console.log(`${colors[color]}${icon}${message}${colors.reset}`);\n}\n\nfunction logSuccess(message) {\n  log(`${message}`, 'green', '✅ ');\n}\n\nfunction logError(message) {\n  log(`${message}`, 'red', '❌ ');\n}\n\nfunction logWarning(message) {\n  log(`${message}`, 'yellow', '⚠️  ');\n}\n\nfunction logInfo(message) {\n  log(`${message}`, 'cyan', 'ℹ️  ');\n}\n\nfunction logHeader(message) {\n  log(`\\n${message}`, 'bright', '🔍 ');\n}\n\n// 🛠️ Platform-specific paths\nfunction getPlatformPaths() {\n  const home = homedir();\n  \n  switch (platform()) {\n    case 'win32':\n      return {\n        dataDir: join(home, 'AppData', 'Roaming', 'Claude', 'knowledge-base'),\n        configDir: join(home, 'AppData', 'Roaming', 'Claude'),\n        configFile: join(home, 'AppData', 'Roaming', 'Claude', 'claude_desktop_config.json')\n      };\n    case 'darwin':\n      return {\n        dataDir: join(home, 'Library', 'Application Support', 'Claude', 'knowledge-base'),\n        configDir: join(home, 'Library', 'Application Support', 'Claude'),\n        configFile: join(home, 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json')\n      };\n    default:\n      return {\n        dataDir: join(home, '.config', 'claude', 'knowledge-base'),\n        configDir: join(home, '.config', 'claude'),\n        configFile: join(home, '.config', 'claude', 'claude_desktop_config.json')\n      };\n  }\n}\n\n// 🖥️ System information\nfunction checkSystemInfo() {\n  logHeader('System Information');\n  \n  logInfo(`Platform: ${platform()} ${arch()}`);\n  logInfo(`CPU: ${cpus()[0].model} (${cpus().length} cores)`);\n  logInfo(`Total Memory: ${formatBytes(totalmem())}`);\n  logInfo(`Free Memory: ${formatBytes(freemem())}`);\n  logInfo(`Node.js: ${process.version}`);\n  logInfo(`Architecture: ${process.arch}`);\n}\n\n// 🔍 Node.js and npm checks\nasync function checkNodeEnvironment() {\n  logHeader('Node.js Environment');\n  \n  try {\n    const { stdout: nodeVersion } = await execAsync('node --version');\n    const majorVersion = parseInt(nodeVersion.trim().substring(1).split('.')[0]);\n    \n    if (majorVersion >= 18) {\n      logSuccess(`Node.js ${nodeVersion.trim()} (Compatible)`);\n    } else {\n      logError(`Node.js ${nodeVersion.trim()} (Requires 18+)`);\n    }\n  } catch (error) {\n    logError('Node.js not found or not accessible');\n  }\n  \n  try {\n    const { stdout: npmVersion } = await execAsync('npm --version');\n    logSuccess(`npm ${npmVersion.trim()}`);\n  } catch (error) {\n    logError('npm not found or not accessible');\n  }\n  \n  try {\n    const { stdout: npxVersion } = await execAsync('npx --version');\n    logSuccess(`npx ${npxVersion.trim()}`);\n  } catch (error) {\n    logWarning('npx not found');\n  }\n}\n\n// 📁 File system checks\nfunction checkFileSystem() {\n  logHeader('File System');\n  \n  const paths = getPlatformPaths();\n  \n  // Check project directory\n  const projectRoot = join(__dirname, '..');\n  if (existsSync(projectRoot)) {\n    logSuccess(`Project directory: ${projectRoot}`);\n  } else {\n    logError(`Project directory not found: ${projectRoot}`);\n  }\n  \n  // Check dist directory\n  const distDir = join(projectRoot, 'dist');\n  if (existsSync(distDir)) {\n    logSuccess(`Build directory exists: ${distDir}`);\n  } else {\n    logWarning(`Build directory missing: ${distDir}`);\n  }\n  \n  // Check main server file\n  const serverFile = join(distDir, 'server-v3.js');\n  if (existsSync(serverFile)) {\n    const stats = statSync(serverFile);\n    logSuccess(`Server file: ${serverFile} (${formatBytes(stats.size)})`);\n  } else {\n    logError(`Server file missing: ${serverFile}`);\n  }\n  \n  // Check data directory\n  if (existsSync(paths.dataDir)) {\n    const stats = statSync(paths.dataDir);\n    logSuccess(`Data directory: ${paths.dataDir}`);\n  } else {\n    logWarning(`Data directory missing: ${paths.dataDir}`);\n  }\n  \n  // Check Claude Desktop config\n  if (existsSync(paths.configFile)) {\n    try {\n      const config = JSON.parse(readFileSync(paths.configFile, 'utf8'));\n      if (config.mcpServers && config.mcpServers['claude-knowledge-base']) {\n        logSuccess('Claude Desktop configuration found and valid');\n      } else {\n        logWarning('Claude Desktop config exists but MCP server not configured');\n      }\n    } catch (error) {\n      logError('Claude Desktop config exists but is invalid JSON');\n    }\n  } else {\n    logWarning(`Claude Desktop config missing: ${paths.configFile}`);\n  }\n}\n\n// 📦 Dependencies check\nasync function checkDependencies() {\n  logHeader('Dependencies');\n  \n  const projectRoot = join(__dirname, '..');\n  const packageJsonPath = join(projectRoot, 'package.json');\n  \n  if (!existsSync(packageJsonPath)) {\n    logError('package.json not found');\n    return;\n  }\n  \n  try {\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));\n    const dependencies = { ...packageJson.dependencies, ...packageJson.optionalDependencies };\n    \n    let installed = 0;\n    let total = Object.keys(dependencies).length;\n    \n    for (const [dep, version] of Object.entries(dependencies)) {\n      try {\n        await execAsync(`npm list ${dep}`, { cwd: projectRoot });\n        installed++;\n      } catch (error) {\n        logWarning(`Missing: ${dep}@${version}`);\n      }\n    }\n    \n    if (installed === total) {\n      logSuccess(`All ${total} dependencies installed`);\n    } else {\n      logWarning(`${installed}/${total} dependencies installed`);\n    }\n    \n  } catch (error) {\n    logError('Failed to parse package.json');\n  }\n}\n\n// 🗄️ Database checks\nfunction checkDatabase() {\n  logHeader('Database');\n  \n  const paths = getPlatformPaths();\n  const dbPath = join(paths.dataDir, 'knowledge-base.db');\n  \n  if (existsSync(dbPath)) {\n    const stats = statSync(dbPath);\n    logSuccess(`Database file: ${dbPath} (${formatBytes(stats.size)})`);\n    logInfo(`Last modified: ${stats.mtime.toISOString()}`);\n  } else {\n    logWarning(`Database file missing: ${dbPath}`);\n  }\n  \n  // Check for backup files\n  const backupPattern = join(paths.dataDir, 'backups');\n  if (existsSync(backupPattern)) {\n    logSuccess('Backup directory exists');\n  } else {\n    logWarning('Backup directory missing');\n  }\n}\n\n// 🔌 Tool integration checks\nasync function checkToolIntegration() {\n  logHeader('Tool Integration');\n  \n  // Check for Desktop Commander\n  try {\n    await execAsync('which desktop-commander || where desktop-commander', { shell: true });\n    logSuccess('Desktop Commander integration available');\n  } catch (error) {\n    logInfo('Desktop Commander not found (optional)');\n  }\n  \n  // Check Git\n  try {\n    const { stdout } = await execAsync('git --version');\n    logSuccess(`Git: ${stdout.trim()}`);\n  } catch (error) {\n    logWarning('Git not found (required for GitHub integration)');\n  }\n  \n  // Check available tools\n  const tools = ['curl', 'wget', 'python', 'python3'];\n  for (const tool of tools) {\n    try {\n      await execAsync(`which ${tool} || where ${tool}`, { shell: true });\n      logInfo(`${tool} available`);\n    } catch (error) {\n      // Silently ignore missing optional tools\n    }\n  }\n}\n\n// 🧪 Performance checks\nasync function checkPerformance() {\n  logHeader('Performance');\n  \n  const freeMemory = freemem();\n  const totalMemory = totalmem();\n  const memoryUsage = ((totalMemory - freeMemory) / totalMemory) * 100;\n  \n  if (freeMemory > 1024 * 1024 * 1024) { // 1GB\n    logSuccess(`Available memory: ${formatBytes(freeMemory)}`);\n  } else {\n    logWarning(`Low available memory: ${formatBytes(freeMemory)}`);\n  }\n  \n  logInfo(`Memory usage: ${memoryUsage.toFixed(1)}%`);\n  \n  // CPU count check\n  const cpuCount = cpus().length;\n  if (cpuCount >= 2) {\n    logSuccess(`CPU cores: ${cpuCount}`);\n  } else {\n    logWarning(`Limited CPU cores: ${cpuCount}`);\n  }\n}\n\n// 📊 Generate health report\nfunction generateHealthReport() {\n  logHeader('Health Summary');\n  \n  // This would contain actual health metrics\n  logSuccess('System is ready for Claude Knowledge Base MCP');\n  logInfo('Run setup script if any issues detected');\n  logInfo('Check installation guide: INSTALL.md');\n}\n\n// 🚀 Main diagnostic function\nasync function main() {\n  log('🧠 Claude Knowledge Base MCP v3.0 - System Doctor', 'bright');\n  log('🇬🇪 Built with love from Batumi, Georgia 🌊\\n', 'magenta');\n  \n  try {\n    checkSystemInfo();\n    await checkNodeEnvironment();\n    checkFileSystem();\n    await checkDependencies();\n    checkDatabase();\n    await checkToolIntegration();\n    await checkPerformance();\n    generateHealthReport();\n    \n    log('\\n🎉 Diagnostic complete!', 'green');\n    log('🇬🇪 Georgian tech excellence confirmed! 🌊', 'magenta');\n    \n  } catch (error) {\n    logError(`Diagnostic failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n// Handle CLI execution\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch(console.error);\n}\n\nexport { main as doctor, getPlatformPaths, checkSystemInfo };